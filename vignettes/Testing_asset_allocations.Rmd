---
title: "Testing Asset Allocation Strategies"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Testing_asset_allocations}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r include=FALSE}
knitr::opts_chunk$set(fig.width=6, fig.height=4) 
```

This vignette illustrates some ways to use the `AssetAllocation` package to backtest simple asset allocations. Example 1 shows how to backtest one of the pre-loaded asset allocations in the `asset_alloc` object.

The available static (i.e., constant weights) allocations are these:

```{r message=FALSE, warning=FALSE}
library(AssetAllocation)
library(PerformanceAnalytics)
names(asset_allocations$static)
```

The dynamic or tactical allocations are these:

```{r}
names(asset_allocations$tactical)
```

Each allocation is represented as a list with fields describing the name of the strategy, the tickers used, the desired weights, the rebalancing frequency, and the rebalancing function. For static asset allocation strategies, this should be set to the function `constant_weights`. For example, Ray Dalio's All Weather Portfolio strategy is defined as follows:

```{r}
asset_allocations$static$all_weather
```

The package comes with returns data to test all strategies in `asset_alloc` using ETFs. The returns are in the `ETFs` data set. Type `?ETFs` for details.

# Example 1: testing a pre-loaded allocation

In this first example, we use the pre-loaded ETFs returns to backtest the Permanent Portfolio allocation. We then plot the cumulative returns.

```{r}
## Example 1: backtesting one of the asset allocations in the package
strat_permanent <- asset_allocations$static$permanent

# test using the data set provided in the package
bt_strat_permanent <- backtest_allocation(strat_permanent, ETFs$Prices, ETFs$Returns, ETFs$risk_free)

# plot cumulative returns
chart.CumReturns(bt_strat_permanent$returns,
                 main = paste0("Cumulative returns of the ",
                               bt_strat_permanent$strat$name,
                               " portfolio"),
                 ylab = "Cumulative returns"
)

# table with performance metrics
bt_strat_permanent$table_performance
```

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}

```

# Example 2: creating and testing a custom allocation

Here we create a custom strategy from scratch. The strategy invests equally in momentum (MTUM), value (VLUE), low volatility (USMV) and quality (QUAL) ETFs.

We first set up this custom strategy as follows:

```{r}
factor_strat  <- list(name = "EW Factors",
                      tickers = c("MTUM", "VLUE", "USMV", "QUAL"),
                      default_weights = c(0.25, 0.25, 0.25, 0.25),
                      rebalance_frequency = "month",
                      portfolio_rule_fn = constant_weights)
```

Next, we can automatically download data and create a returns matrix using the `get_return_data_from_tickers` function:

```{r warning=FALSE}
factor_ETFs <- get_data_from_tickers(factor_strat$tickers,
                                      starting_date = "2013-08-01")

```

Finally, we backtest the strategy and show the results:

```{r}
# backtest the strategy
bt_factor_strat <- backtest_allocation(factor_strat,
                                       factor_ETFs$P,
                                       factor_ETFs$R)
# plot returns
library(PerformanceAnalytics)
chart.CumReturns(bt_factor_strat$returns,
                 main = paste0("Cumulative returns of the ",
                               bt_factor_strat$strat$name,
                               " portfolio"),
                 ylab = "Cumulative returns"
)

# table with performance metrics
bt_factor_strat$table_performance
```

# Example 3: Testing tactical asset allocation strategies

In this example, we test and compare three tactical aaset allocation strategies: the Ivy Portfolio, the Robust Asset Allocation strategy, and the Dual Momentum strategy.

```{r}
# define strategies
ivy <- asset_allocations$tactical$ivy
raa <- asset_allocations$tactical$raa
dual_mo <- asset_allocations$tactical$dual_mo

# run backtests
bt_ivy <- backtest_allocation(ivy, ETFs$Prices,ETFs$Returns, ETFs$risk_free)
bt_raa <- backtest_allocation(raa, ETFs$Prices,ETFs$Returns, ETFs$risk_free)
bt_dual_mo <- backtest_allocation(dual_mo, ETFs$Prices,ETFs$Returns, ETFs$risk_free)

# 
ret_strats <- (merge.xts(bt_ivy$returns, bt_raa$returns, bt_dual_mo$returns))

# find index from which all strats are available
min_ind <- which.max(!is.na(rowSums(ret_strats)))

charts.PerformanceSummary(ret_strats[min_ind:nrow(ret_strats)])

```
